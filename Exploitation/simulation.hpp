#ifndef DEF_SIMULATION
#define DEF_SIMULATION

#include <vector>
#include <cstdlib>
#include "individu.hpp"
#include "vect.hpp"
#include "champ_de_vitesse.hpp"

class Individu;

template <unsigned int TAILLE_GRILLE>
class Simulation
{
	public :
		Simulation();

		void addSortie(int x, int y);
		void addPylone(unsigned int x, unsigned int y);
		void addIndiv(double x, double y);
		void addNIndiv(unsigned int n);
		int run();
		std::vector<Individu*>* getVecteursCase(int x, int y) const;
		std::vector<Individu*> alentours(int l, unsigned int x, unsigned int y);
		int champVitesses(const unsigned int l, const unsigned int c) const;

	private :
		std::vector<Vect> m_sorties;
		std::vector<Vect> m_murs;
		std::vector<Individu*>* m_liste[TAILLE_GRILLE][TAILLE_GRILLE];
		std::vector<Vect>* m_distances_sorties;
		std::vector<std::vector<int>>* m_champ_vitesses;
		int m_compteur;
};

/* Implementation */
template<unsigned int TAILLE_GRILLE>
Simulation<TAILLE_GRILLE>::Simulation()
{
	m_champ_vitesses = new std::vector<std::vector<int>>(TAILLE_GRILLE);
	for (unsigned int i=0; i<TAILLE_GRILLE; i++) {
		(*m_champ_vitesses)[i] = std::vector<int>(TAILLE_GRILLE, 0);
	}

	m_distances_sorties = new std::vector<Vect>;

	for (unsigned int i=0; i<TAILLE_GRILLE; i++) {
		for (unsigned int j=0; j<TAILLE_GRILLE; j++) {
			m_liste[i][j] = new std::vector<Individu*>;
		}
	}

	m_compteur = 0;
}

template<unsigned int TAILLE_GRILLE>
void Simulation<TAILLE_GRILLE>::addSortie(int x, int y)
{
	m_sorties.push_back({x,y});
}

template<unsigned int TAILLE_GRILLE>
void Simulation<TAILLE_GRILLE>::addPylone(unsigned int x, unsigned int y)
{
	double r = 0.35;
	bool ok = true;
	std::vector<Individu*>* sous_liste;
	Individu* ind_lambda;
	int iter;

	for(unsigned int i=(x-1<0?0:x-1); i<=x+1 && i<TAILLE_GRILLE && ok; i++)
	{
		for(unsigned int j=(y-1<0?0:y-1); j<TAILLE_GRILLE && j<=y+1 && ok; j++)
		{
			sous_liste = getVecteursCase(i,j);
			iter = sous_liste->size();
			for(int k=0; k<iter; k++)
			{
				ind_lambda = sous_liste->at(k);
				if((ind_lambda->getPos()-Vect(x,y)).norme()<ind_lambda->getR()+r) // Si plus proches que leur rayon
				{
					ok = false;
					break;
				}
			}
		}
	}

	if(ok)
	{
		m_murs.push_back(Vect(x,y));
		Individu* ptr_indiv = new Individu(x+0.5,y+0.5,r,0,0, true);
		m_liste[x][y]->push_back(ptr_indiv);
	}
}

template<unsigned int TAILLE_GRILLE>
void Simulation<TAILLE_GRILLE>::addIndiv(double x, double y)
{
	double r = 0.2;
	bool ok = true;
	std::vector<Individu*>* sous_liste;
	Individu* ind_lambda;
	int iter;

	for(unsigned int i=(x-1<0?0:x-1); i<=x+1 && i<TAILLE_GRILLE && ok; i++)
	{
		for(unsigned int j=(y-1<0?0:y-1); j<TAILLE_GRILLE && j<=y+1 && ok; j++)
		{
			sous_liste = getVecteursCase(i,j);
			iter = sous_liste->size();
			for(int k=0; k<iter; k++)
			{
				ind_lambda = sous_liste->at(k);
				if((ind_lambda->getPos()-Vect{x,y}).norme()<ind_lambda->getR()+r) // Si plus proches que leur rayon
				{
					ok = false;
					break;
				}
			}
		}
	}

	if(ok)
	{
		Individu* ptr_indiv = new Individu(x, y, r, 7*r, 14*r, false);
		m_liste[int(x)][int(y)]->push_back(ptr_indiv);
		m_compteur++;
	}
}

template<unsigned int TAILLE_GRILLE>
void Simulation<TAILLE_GRILLE>::addNIndiv(unsigned int n)
{
	for(unsigned int i=0; i<n; i++)
	{
		addIndiv(2.+(TAILLE_GRILLE-4)*(rand()/(double)RAND_MAX), 2.+(TAILLE_GRILLE-4)*(rand()/(double)RAND_MAX));
	}
}

template<unsigned int TAILLE_GRILLE>
int Simulation<TAILLE_GRILLE>::run()
{
	bool escape = false;
	std::vector<Individu*>* sous_liste;
	int iter;
	unsigned int nb_cases = 0;
	Individu* ptr_indiv = NULL;

    calculs_champs(TAILLE_GRILLE, m_sorties, m_murs, m_distances_sorties, m_champ_vitesses);
    nb_cases = m_distances_sorties->size();
    std::cout << "Calcul du champ termine" << std::endl;
    int nb_etapes = 0;
    int nb_indiv = m_compteur;

	while (m_compteur > 0)
	{

		// Mouvement individus
		for(unsigned int i=0; i<nb_cases; i++)
		{
			sous_liste = getVecteursCase(m_distances_sorties->at(i).getX(),m_distances_sorties->at(i).getY());
			iter = sous_liste->size()-1;
			for(int k=iter; k>-1; k--)
			{
				ptr_indiv = sous_liste->at(k);
				ptr_indiv->calculVitesse(this);
				int x = ptr_indiv->getX();
				int y = ptr_indiv->getY();
				escape = ptr_indiv->move(m_champ_vitesses);
				int xp = ptr_indiv->getX();
				int yp = ptr_indiv->getY();
				if (x != xp || y != yp)
				{
					m_liste[x][y]->erase(m_liste[x][y]->begin()+recherche(m_liste[x][y],ptr_indiv));
					m_liste[xp][yp]->push_back(ptr_indiv);
				}
				if(escape)
				{
					m_liste[x][y]->erase(m_liste[x][y]->begin()+recherche(m_liste[x][y],ptr_indiv));
					m_compteur--;
					delete ptr_indiv;
				}
            }
        }
		//Murs
		for(unsigned int i=0; i<m_murs.size(); i++)
		{
			getVecteursCase(m_murs.at(i).getX(), m_murs.at(i).getY())->at(0);
		}

        nb_etapes++;
	}

    std::cout << "Simulation Terminee" << std::endl;

	delete m_champ_vitesses;
	delete m_distances_sorties;

    return (nb_etapes)*10000+nb_indiv-10;
}

template<unsigned int TAILLE_GRILLE>
std::vector<Individu*>* Simulation<TAILLE_GRILLE>::getVecteursCase(int x, int y) const
{
	return m_liste[x][y];
}

template<unsigned int TAILLE_GRILLE>
std::vector<Individu*> Simulation<TAILLE_GRILLE>::alentours(int l, unsigned int x, unsigned int y)
{
	l= l<1 ? 1 : l;
	unsigned int gauche = x-l;
	unsigned int droite = x+l;
	unsigned int bas = y-l;
	unsigned int haut = y+l;
	unsigned int t = TAILLE_GRILLE-1;
	std::vector<Individu*> lindiv(0);
	for(unsigned int i=(gauche<0?0:gauche); i<=(droite>t?t:droite); i++)
	{
		for(unsigned int j=(bas<0?0:bas); j<=(haut>t?t:haut); j++)
		{
			lindiv.insert(lindiv.end(),m_liste[i][j]->begin(),m_liste[i][j]->end());
		}
	}
	return lindiv;
}

template<unsigned int TAILLE_GRILLE>
int Simulation<TAILLE_GRILLE>::champVitesses(const unsigned int l, const unsigned int c) const
{
	return m_champ_vitesses->at(l).at(c);
}

#endif
